import idaapi, idc, idautils
import json


addresses = [0]
push_pop_dict = {}
jmp_dict = {} 


seg_mapping = {idaapi.getseg(x).name: (idaapi.getseg(x).start_ea, idaapi.getseg(x).end_ea) for x in
                   idautils.Segments()}
start = seg_mapping[0x1][0]
end = seg_mapping[0x1][1]

def is_Data(value):
    if len(str(value)) > 6:
         return 1
  
def set_hexrays_comment(address, text):
    cfunc = idaapi.decompile(address)
    tl = idaapi.treeloc_t()
    tl.ea = address
    tl.itp = idaapi.ITP_SEMI
    cfunc.set_user_cmt(tl, text)
    cfunc.save_user_cmts() 


def set_comment(address, text):
    idc.set_cmt(address, text,0)
    set_hexrays_comment(address, text.replace("\\" , "_"))



def rc4crypt(data, key):

    if type(data) == str:
        data = data.encode('utf-8')
    if type(key) == str:
        key = key.encode('utf-8')
    x = 0
    box = list(range(256))
    for i in range(256):
        x = (x + box[i] + key[i % len(key)]) % 256
        box[i], box[x] = box[x], box[i]
    x = 0
    y = 0
    out = []
    for c in data:
        x = (x + 1) % 256
        y = (y + box[x]) % 256
        box[x], box[y] = box[y], box[x]
        out.append(c ^ box[(box[x] + box[y]) % 256])
    return bytes(out)
    
    
def get_reg_value(ea, reg_name):   # shout-out to OALabs https://gist.github.com/OALabs/04ef6b2d6203d162c5b3b0eefd49530c
    e_count = 0
    ptr_addr = ea
    ## Just for safety only count back 500 heads
    while e_count < 500:
        e_count += 1
        ptr_addr = idc.prev_head(ptr_addr)
        if idc.print_insn_mnem(ptr_addr) == 'mov':
            if idc.get_operand_type(ptr_addr, 0) == idc.o_reg:
                tmp_reg_name = idaapi.get_reg_name(idc.get_operand_value(ptr_addr, 0), 4)
                if reg_name== tmp_reg_name:
                    if idc.get_operand_type(ptr_addr, 1) == idc.o_imm:
                        return hex(idc.get_operand_value(ptr_addr, 1))
        if idc.print_insn_mnem(ptr_addr) == 'retn':
            return ""
        elif idc.print_insn_mnem(ptr_addr) == 'pop':
            ## Match the following pattern
            ## push    3
            ## pop     edi
            if idc.get_operand_type(ptr_addr, 0) == idc.o_reg:
                tmp_reg_name = idaapi.get_reg_name(idc.get_operand_value(ptr_addr, 0), 4)
                if reg_name.lower() == tmp_reg_name.lower():
                    ## Get prev command
                    tmp_addr = idc.prev_head(ptr_addr)
                    if idc.print_insn_mnem(tmp_addr) == 'push':
                        if idc.get_operand_type(tmp_addr, 0) == idc.o_imm:
                            reg_value = idc.get_operand_value(tmp_addr, 0)
                            return hex(reg_value)
        elif idc.print_insn_mnem(ptr_addr) == 'ret':
            ## We ran out of space in the function
           return ""



def getdata(ptr_addr):

    args_lengths = []
    args_data = []
    arg_count = 0
    reg_name = ''
    jump_val = 0
    
    while arg_count < 4:
        ptr_addr = idc.prev_head(ptr_addr)
 
        
        if idc.print_insn_mnem(ptr_addr) == 'push' and idc.get_operand_type(ptr_addr, 0) == idc.o_mem : #push    dword_
              value = hex(idc.get_wide_dword(idc.get_operand_value(ptr_addr, 0)))
              if is_Data(value) :
                args_data.append(value)
                arg_count += 1
              else:
                if len(args_lengths) != 2:
                    args_lengths.append(value)
                    arg_count += 1
                    
        if idc.print_insn_mnem(ptr_addr) == 'push' and idc.get_operand_type(ptr_addr, 0) == idc.o_imm: # push    offset unk_414390
              value = hex(idc.get_operand_value(ptr_addr, 0))
              if is_Data(value) :
                args_data.append(value)
                arg_count += 1
              else: 
                if len(args_lengths) != 2:
                    args_lengths.append(value)
                    arg_count += 1
                    
        if idc.print_insn_mnem(ptr_addr) == 'push' and idc.get_operand_type(ptr_addr, 0) == idc.o_reg: # if a paramter is pushed in reg
              reg_name = idaapi.get_reg_name(idc.get_operand_value(ptr_addr, 0), 4)
              reg_value = get_reg_value(ptr_addr,reg_name)
              if reg_value != "":
                  if is_Data(reg_value) :
                        args_data.append(reg_value)
                        arg_count += 1
                  else: 
                        if len(args_lengths) != 2:
                            args_lengths.append(reg_value)
                            arg_count += 1
                            
                            
        if idc.print_insn_mnem(ptr_addr) == 'jz' or idc.print_insn_mnem(ptr_addr) == "jnb":  # trace paramters pushed before jmp
            if idc.print_insn_mnem(idc.prev_head(ptr_addr)) == 'push' and idc.get_operand_type(idc.prev_head(ptr_addr), 0) == idc.o_imm:
                  jmp_dict[idc.get_operand_value(ptr_addr, 0)] = hex(idc.get_operand_value(idc.prev_head(ptr_addr), 0))
                 
       
       
        if ptr_addr in  jmp_dict:  # if a paramter is pushed  and  jmp encountered
            jump_val = jmp_dict[ptr_addr]
            if is_Data(jump_val):
                        args_data.append(jump_val)
                        arg_count += 1
            else: 
                        if len(args_lengths) != 2:
                            args_lengths.append(jump_val)
                            arg_count +=1
                            
        if idc.print_insn_mnem(ptr_addr) == 'mov'and idc.get_operand_type(ptr_addr, 0) == idc.o_reg and idc.get_operand_type(ptr_addr, 1) == idc.o_imm: # mov     ecx, offset unk_
                value = hex(idc.get_operand_value(ptr_addr, 1))
                if is_Data(value):
                    args_data.append(value)
                    arg_count += 1
                else: 
                    if len(args_lengths) != 2:
                        args_lengths.append(value)
                        arg_count += 1
       
        if ptr_addr == addresses[-2]: # if encoutered a previous decryption , then the last paramter need is pushed in esi 
           args_lengths.append(hex(push_pop_dict["esi"]))
           arg_count += 1
           
        if idc.print_insn_mnem(ptr_addr) == 'pop':  
                     ## Match the following pattern
                     ## push    3
                     ## pop     edi
                    if idc.get_operand_type(ptr_addr, 0) == idc.o_reg:
                        tmp_reg_name = idaapi.get_reg_name(idc.get_operand_value(ptr_addr, 0), 4)
                        tmp_addr = idc.prev_head(ptr_addr)
                        if idc.print_insn_mnem(tmp_addr) == 'push':
                                if idc.get_operand_type(tmp_addr, 0) == idc.o_imm:
                                    reg_value = idc.get_operand_value(tmp_addr, 0)
                                    push_pop_dict[tmp_reg_name] = reg_value
    return args_lengths ,args_data               

def decrypt_all_strings(fn_address,end):

    c = 0
    for ref in idautils.XrefsTo(fn_address):
        c+=1
        addr = ref.frm
        addresses.append(addr)
        args_lengths , args_data = getdata(addr)
        args_data.sort() 
        
        try: # the first length pushed is the key length , but sometimes the data length is added first in len_arg list , so i use try and catch to check both if one fails it means that we need to swap the lenghts 
    
            key_data = idc.get_bytes(int(args_data[0],16),int(args_lengths[0],16))
            str_data = idc.get_bytes(int(args_data[1],16), int(args_lengths[1],16))
            plaintxt_str =  rc4crypt(str_data, key_data).replace(b'\x00',b'')
            set_comment(addr,plaintxt_str.decode())


        except:
            if c == 51 : # weird decrypted string ? "cþ¡¤ÿfæ.. [Q]:.wµAI.W3M¨ÿþrè"  
                continue
            else:

                key_data = idc.get_bytes(int(args_data[0],16),int(args_lengths[1],16))
                str_data = idc.get_bytes(int(args_data[1],16), int(args_lengths[0],16))
                plaintxt_str =  rc4crypt(str_data, key_data).replace(b'\x00',b'')
                plaintxt_str = plaintxt_str.decode()
                set_comment(addr,plaintxt_str)
    

decrypt_all_strings(0x0406630 ,end)

