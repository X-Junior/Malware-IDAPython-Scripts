import idautils , idc, idaapi, ida_search, ida_bytes, ida_auto
import string , struct , base64


def xor_decryption(encoded_string , xor_key):
	encoded_string = base64.b64decode(encoded_string)
	decoded_str = ""

	for i in range(len(encoded_string)):
		decoded_str += chr(encoded_string[i] ^ xor_key[i%len(xor_key)])
	return decoded_str


def sub_decryption(encdata, sub_byte):
	try:
		if encdata != []:
			out = bytearray((ord(encdata[j]) - sub_byte) %
						256 for j in range(len(encdata)))
			return out.decode()
	except Exception as e :
		return 0

def add_decryption(encdata, add_byte):
	try:
		if encdata != []:
			out = bytearray((ord(encdata[j]) + add_byte) %
						256 for j in range(len(encdata)))
			return out.decode()
	except Exception as e :
		return 0

def extract_key(ea):
	xor_key_list = []
	for i in range(10):
		try:
			if (idc.print_insn_mnem(ea) == "movdqa"  and (idc.get_operand_type(ea, 0) == idc.o_reg) and (idc.get_operand_type(ea, 1) == idc.o_mem) ) :
				temp_xor_key = idc.get_bytes(idc.get_operand_value(ea, 1),200).split(b'\x00')[0]
				temp_xor_key = temp_xor_key.split(b'\xff')[0]
				temp_xor_key.decode()
				xor_key_list.append(temp_xor_key)
			if (idc.print_insn_mnem(ea) == "mov"  and (idc.get_operand_type(ea, 1) == idc.o_imm) ) :
				xor_key_list.append(struct.pack('<I',idc.get_operand_value(ea, 1)).replace(b'\x00',b''))
			ea =  idc.prev_head(ea)
		except:
			continue
	xor_key_list = xor_key_list[::-1]
	xor_key = b''.join(xor_key_list)
	return xor_key


def extract_dec_byte(start,end):
	regex = "44 0F B6 0E 41 80 ?? ?? 48 8B 4B ?? 48 8B 53 ?? 48 3B CA 73 ?? 48 8D 41 ?? 48 89 43"
	regex_addr = ida_search.find_binary(start, end, regex, 16, idc.SEARCH_DOWN)
	ea = regex_addr
	dec_option = 0
	for i in range(3):
		if (idc.print_insn_mnem(ea) == "add"):
			dec_option = 1
			dec_byte = idc.get_operand_value(ea, 1)
		elif (idc.print_insn_mnem(ea) == "sub"):
			dec_option = 0
			dec_byte = idc.get_operand_value(ea, 1)
		ea = idc.next_head(ea, end)
	return dec_byte , dec_option


def extract_enc_string_with_offsets(regex_addr_begin):
	enc_string_with_offset = {}
	for ref in idautils.XrefsTo(regex_addr_begin):
		addr = ref.frm
		ea = addr
		for i in range(20):
			if (idc.print_insn_mnem(ea) == "lea"  and (idc.get_operand_type(ea, 0) == idc.o_reg) and (idc.get_operand_type(ea, 1) == idc.o_mem)) and i > 4 :
					temp_name = idc.get_bytes(idc.get_operand_value(ea,1),5000).split(b'\x00')[0]
					enc_string_with_offset[ea] = temp_name
					break
			ea =  idc.prev_head(ea)
	return enc_string_with_offset

def set_hexrays_comment(address, text):
	cfunc = idaapi.decompile(address)
	tl = idaapi.treeloc_t()
	tl.ea = address
	tl.itp = idaapi.ITP_SEMI
	cfunc.set_user_cmt(tl, text)
	cfunc.save_user_cmts()
	ea = idaapi.get_screen_ea()


seg_mapping = {idaapi.getseg(x).name: (idaapi.getseg(x).start_ea, idaapi.getseg(x).end_ea) for x in idautils.Segments()}
start = seg_mapping[0x1][0]
end = seg_mapping[0x1][1]

regex = "4C 89 6D ?? 4C 8B 67 ?? 48 8B F7 48 83 7F ?? ?? 72 ?? 48 8B 37"
regex_addr = ida_search.find_binary(start, end, regex, 16, idc.SEARCH_DOWN)
regex_addr_begin = idaapi.get_func(regex_addr).start_ea


enc_string_with_offset = extract_enc_string_with_offsets(regex_addr_begin)
xor_key = extract_key(regex_addr)
dec_byte , dec_option = extract_dec_byte(start,end)

for offset, data in enc_string_with_offset.items():
	decoded_string = xor_decryption(data, xor_key)
	if dec_option == 0:
		decoded_string = sub_decryption(decoded_string ,dec_byte)
	else:
		decoded_string = add_decryption(decoded_string ,dec_byte)
	print(hex(offset) , decoded_string)
	set_hexrays_comment(offset , decoded_string)
	idc.set_cmt(offset, decoded_string, 1)