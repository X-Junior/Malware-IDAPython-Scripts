import idautils , idc, idaapi, ida_search, ida_bytes, ida_auto
import struct , json

decrypted_strings = []

def rename_api(ea ,end,name):
    while 1:
            ea = idc.next_head(ea, end)
            if (idc.print_insn_mnem(ea) == "mov") and (idc.get_operand_type(ea, 0) == idc.o_mem) and (idc.get_operand_type(ea, 1) == idc.o_reg):
                global_var = idc.get_operand_value(ea, 0)
                idc.set_name(global_var, name,idaapi.SN_FORCE)
                break

def xor(data, key):
    out = []
    for i in range(len(data)):
        out.append(data[i] ^ key[i % len(key)])
    return bytes(out)

def get_data(ea ,end ):

        xored_data = b''
        if (idc.print_insn_mnem(ea) == "mov") and (idc.get_operand_type(ea, 0) == idc.o_displ) and (idc.get_operand_type(ea, 1) == idc.o_imm):
            key = idc.generate_disasm_line(ea, 0).replace(']', '-').replace('[', '-').split('-')[2]
            hex_data = hex(idc.get_operand_value(ea, 1))[2:]
            hex_data = "0" * (8 - len(hex_data)) + hex_data
            hex_data =  hex(struct.unpack('<I', bytes.fromhex(hex_data))[0])[2:]
            hex_data = "0" * (8 - len(hex_data)) + hex_data
            xored_data += bytes.fromhex(hex_data) 
            
            while len(xored_data) != 16:
                ea = idc.next_head(ea, end)
                if (idc.print_insn_mnem(ea) == "mov") and (idc.get_operand_type(ea, 0) == idc.o_displ) and (idc.get_operand_type(ea, 1) == idc.o_imm):
                    reg = idc.generate_disasm_line(ea, 0).replace(']', '-').replace('[', '-').split('-')[1]
                    
                    if "+" in reg :
                        reg = reg.split("+")[0]
                    
                    if  reg =="ebp" or  reg =="esp":
                        hex_data = hex(idc.get_operand_value(ea, 1))[2:]
                        hex_data = "0" * (8 - len(hex_data)) + hex_data
                        hex_data = hex(struct.unpack('<I', bytes.fromhex(hex_data))[0])[2:]
                        hex_data = "0" * (8 - len(hex_data)) + hex_data
                        xored_data += bytes.fromhex(hex_data)         
            return xored_data
            
def decrypt(addr,end):

    var_list = []
    ea = addr 
    key1 , key2= '' , ''
    flag = 1
    
    if "-" in idc.generate_disasm_line(ea, 0):
        key1 = idc.generate_disasm_line(ea, 0).replace(']', '-').split('-')[1]
    else:   
        key1 = idc.generate_disasm_line(ea  , 0).replace("+","|").replace(']', '+').replace('[', '+').split('+')[1]
        
    ea = idc.prev_head(ea)
    
    while 1:                
        
        if (idc.print_insn_mnem(ea) == "movaps") and (idc.get_operand_type(ea, 0) == idc.o_reg) and (idc.get_operand_type(ea, 1) == idc.o_displ) and flag:
                if "-" in idc.generate_disasm_line(ea, 0):
                    key2 = idc.generate_disasm_line(ea, 0).replace(']', '-').split('-')[1]
                else:
                    key2 = idc.generate_disasm_line(ea  , 0).replace("+","|").replace(']', '+').replace('[', '+').split('+')[1]
                flag = 0
        
        
        if (idc.print_insn_mnem(ea) == "mov") and (idc.get_operand_type(ea, 0) == idc.o_displ) and (idc.get_operand_type(ea, 1) == idc.o_imm):
                   
                   if "-" in idc.generate_disasm_line(ea, 0):
                        key = idc.generate_disasm_line(ea, 0).replace(']', '-').split('-')[1]
                        if key1 ==  key or key2 == key :
                                   var_list.append(get_data(ea,end))
                   else:
                        key = idc.generate_disasm_line(ea  , 0).replace("+","|").replace(']', '+').replace('[', '+').split('+')[1]
                        if key1 ==  key or key2 == key :
                                   var_list.append(get_data(ea,end))
                    
        if len(var_list) == 2:
            ecrypted_string = xor(var_list[0], var_list[1])
            return ecrypted_string

        ea = idc.prev_head(ea)    



pattern =  "66 0F EF ?? ?? ?? ?? ?? "

seg_mapping = {idaapi.getseg(x).name: (idaapi.getseg(x).start_ea, idaapi.getseg(x).end_ea) for x in
                   idautils.Segments()}
start = seg_mapping[0x1][0]
end = seg_mapping[0x1][1]

    
def resolve(start,end,pattern):

    prev_stack_pos = 0
    
    while True:
        start = ida_search.find_binary(start, end, pattern, 16, idc.SEARCH_NEXT|idc.SEARCH_DOWN)
        if start == idc.BADADDR:
                break
        ea = start
        
        if (idc.print_insn_mnem(ea) == "pxor") and (idc.get_operand_type(ea, 0) == idc.o_reg) and (idc.get_operand_type(ea, 1) == idc.o_displ):
            decrypted_string = decrypt(ea,end ).replace(b'\x00',b'')
            
            try:
                decrypted_string =  decrypted_string.decode() 
                idc.set_cmt(ea, decrypted_string, 1)
            except:
                decrypted_string = decrypted_string[:-2].decode()
                idc.set_cmt(ea, decrypted_string, 1)
                
            
                
            while 1:
                if (idc.print_insn_mnem(ea) == "movaps") and (idc.get_operand_type(ea, 0) == idc.o_displ) and (idc.get_operand_type(ea, 1) == idc.o_reg):
                    disassm = idc.generate_disasm_line(ea, 0)
                    
                    if "+" in disassm:
                        curr_stack_pos = 0x0
                    else:
                        curr_stack_pos =  int(disassm.replace(']', '-').replace('[', '-').split('-')[2][:-1],16)
                    break
                        
                ea = idc.next_head(ea, end)
           
            if prev_stack_pos - 0x10  ==  curr_stack_pos:   
                decrypted_string = decrypted_strings[-1] + decrypted_string
                decrypted_strings[-1] = decrypted_string
            else:
                decrypted_strings.append(decrypted_string)
                
            prev_stack_pos = curr_stack_pos
            
resolve(start,end,pattern)
