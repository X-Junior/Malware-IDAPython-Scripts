"""
Tested Samples:
Main Component:
02a99e4d1d638ff0df8d018c8502203417bc6953ce0a39b33324c7884d964358
077225467638a420cf29fb9b3f0241416dcb9ed5d4ba32fdcf2bf28f095740bb
977c99590f96d970f726b080dc087d64fe46b6452c4e30d3595d9ed9e2379576
9d5de0848c98678b675d1a186677bacfea15d8bebe5902364149ef285c4f0f1b

Loader Component:
6d29a14b0d37d4556a245ce7d6f5ce74c869141092ab7be79960a0667597e07b
d75a7ee1a791ac1260fa1e83e6cd066dcf1446f2d52b136d226b8de8c284cd06
"""

import idautils , idc, idaapi, ida_search, ida_bytes, ida_auto
import struct , json

def rename_api(ea ,end,name):
    while 1:
            ea = idc.next_head(ea, end)
            if (idc.print_insn_mnem(ea) == "mov") and (idc.get_operand_type(ea, 0) == idc.o_mem) and (idc.get_operand_type(ea, 1) == idc.o_reg):
                global_var = idc.get_operand_value(ea, 0)
                idc.set_name(global_var, name,idaapi.SN_FORCE)
                break
                
                
def byte_xor(ba1, ba2):
    return bytes([_a ^ _b for _a, _b in zip(ba1, ba2)])

exports_json = json.loads(open('exports.json', 'rb').read())
exports_list = exports_json['exports']
                     

seg_mapping = {idaapi.getseg(x).name: (idaapi.getseg(x).start_ea, idaapi.getseg(x).end_ea) for x in
                   idautils.Segments()}
start = seg_mapping[0x1][0]
end = seg_mapping[0x1][1]

pattern = "66 0f ef"

def Get_Chunks(ea):

    ptr_addr = ea
    Data_Chunks = []
    
    count = 0
    steps = 0
    steps_flag = 0
    flag_reg = 0
    
    for i in range(140):
         Data_Chunk = b''
         ptr_addr = idc.prev_head(ptr_addr)
         steps +=1
         
         if  idc.print_insn_mnem(ptr_addr) == 'call':
          break

         if  idc.print_insn_mnem(ptr_addr) == 'mov'and  idc.get_operand_type(ptr_addr, 0) == idc.o_reg  and  idc.get_operand_type(ptr_addr, 1) == idc.o_imm:
            flag_reg = 1
         
         if  idc.print_insn_mnem(ptr_addr) == 'mov'and  ( idc.get_operand_type(ptr_addr, 0) == idc.o_displ or idc.get_operand_type(ptr_addr, 0) == idc.o_reg ) and  idc.get_operand_type(ptr_addr, 1) == idc.o_imm:
                hex_data = hex(idc.get_operand_value(ptr_addr, 1))[2:]
                hex_data = "0" * (8 - len(hex_data)) + hex_data
                hex_data = hex(struct.unpack('<I', bytes.fromhex(hex_data))[0])[2:]
                hex_data = "0" * (8 - len(hex_data)) + hex_data
                Data_Chunk += bytes.fromhex(hex_data)
                Data_Chunks.append(Data_Chunk)
                
                count += 1
                steps = 0
                steps_flag =1
         
         if steps == 6 and steps_flag:
            break
    
    Enc_Data = Data_Chunks[0:count//2][::-1]
    key = Data_Chunks[count//2:count][::-1]
    
    if flag_reg :
            Enc_Data = sum(zip(Enc_Data[1::2], Enc_Data[::2]), ())
            key = sum(zip(key[1::2], key[::2]), ())
    return Enc_Data,key    
    


def Magic(start,end,pattern):
   
    while True:
        start = ida_search.find_binary(start, end, pattern, 16, idc.SEARCH_NEXT|idc.SEARCH_DOWN)
        if start == idc.BADADDR:
                break
        ea = start
      
        Enc_Data ,key = Get_Chunks(ea)
        Enc_Data = b"".join(Enc_Data)
        key = b"".join(key)
        Dec_Data = byte_xor(Enc_Data,key).replace(b'\x00',b'')
      
        if Dec_Data != b'':
         try:
            Dec_Data = Dec_Data.decode()
            print(hex(ea),Dec_Data)
            idc.set_cmt(ea, Dec_Data, 1)
            if Dec_Data in exports_list:
                    rename_api(ea,end,Dec_Data)
         except:
            continue
            
Magic(start,end,pattern)
