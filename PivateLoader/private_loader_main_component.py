import idautils , idc, idaapi, ida_search, ida_bytes, ida_auto
import struct , json


exports_json = json.loads(open('exports.json', 'rb').read())
exports_list = exports_json['exports']

seg_mapping = {idaapi.getseg(x).name: (idaapi.getseg(x).start_ea, idaapi.getseg(x).end_ea) for x in
                   idautils.Segments()}
start = seg_mapping[0x1][0]
end = seg_mapping[0x1][1]

exclued_addr = []

pattern1 = "c7 45 ?? ?? ?? ?? ?? c7 45 ?? ?? ?? ?? ?? c7 45 ?? ?? ?? ?? ?? c7 45 ?? ?? ?? ?? ??"
pattern2 = "c7 85 ?? ?? ff ff ?? ?? ?? ?? c7 85 ?? ?? ff ff ?? ?? ?? ?? c7 85 ?? ?? ff ff ?? ?? ?? ?? c7 85 ?? ?? ff ff ?? ?? ?? ?? "


def xor(data, key):
    out = []
    for i in range(len(data)):
        out.append(data[i] ^ key[i % len(key)])
    return bytes(out)
 
def recheck_addr(addr,end):
    data_start_addr = idc.prev_head(addr)
    while 1:
        if (idc.print_insn_mnem(data_start_addr) == "mov") and (idc.get_operand_type(data_start_addr, 0) == idc.o_displ) and ( idc.get_operand_type(data_start_addr, 1) == idc.o_imm):
            data_start_addr = idc.prev_head(data_start_addr)
        else:
            return idc.next_head(data_start_addr, end)
            
def rename_api(ea ,end,name):
    while 1:
            ea = idc.next_head(ea, end)
            if (idc.print_insn_mnem(ea) == "mov") and (idc.get_operand_type(ea, 0) == idc.o_mem) and (idc.get_operand_type(ea, 1) == idc.o_reg):
                global_var = idc.get_operand_value(ea, 0)
                idc.set_name(global_var, name,idaapi.SN_FORCE)
                break
                
def decrypt(ea):
    xored_data = b''
    decrypted_string = b''
    decrypted_string_parts = []
    stack_dict = {}
    key_list = []

    while 1:
    
        if (idc.print_insn_mnem(ea) == "mov") and (idc.get_operand_type(ea, 0) == idc.o_displ) and (idc.get_operand_type(ea, 1) == idc.o_imm):
            
            xored_data = b''
            key = idc.generate_disasm_line(ea, 0).replace(']', '-').split('-')[1]
            hex_data = hex(idc.get_operand_value(ea, 1))[2:]
            hex_data = "0" * (8 - len(hex_data)) + hex_data
            hex_data =  hex(struct.unpack('<I', bytes.fromhex(hex_data))[0])[2:]
            hex_data = "0" * (8 - len(hex_data)) + hex_data
            xored_data += bytes.fromhex(hex_data)
            
            for i in range(3):
            
                ea = idc.next_head(ea, end)
                hex_data = hex(idc.get_operand_value(ea, 1))[2:]
                hex_data = "0" * (8 - len(hex_data)) + hex_data
                hex_data = hex(struct.unpack('<I', bytes.fromhex(hex_data))[0])[2:]
                hex_data = "0" * (8 - len(hex_data)) + hex_data
                xored_data += bytes.fromhex(hex_data)
                
            stack_dict[key] = xored_data
            
          
        if (idc.print_insn_mnem(ea) == "movaps") and (idc.get_operand_type(ea, 0) == idc.o_reg) and (idc.get_operand_type(ea, 1) == idc.o_displ) or (idc.print_insn_mnem(ea) == "lea") and (idc.get_operand_type(ea, 0) == idc.o_reg) and (idc.get_operand_type(ea, 1) == idc.o_displ):
            
            key = idc.generate_disasm_line(ea, 0).replace(']', '-').split('-')[1]
            
            if key in list(stack_dict.keys()):
                key_list.append(key)
            
            if len(key_list) == 2:
                decrypted_string = xor(stack_dict[key_list[0]], stack_dict[key_list[1]])
                decrypted_string_parts.append(decrypted_string.decode().replace('\x00',''))
                del stack_dict[key_list[0]]
                del stack_dict[key_list[1]]
                key_list = []
            
            if list(stack_dict.keys()) == []:
                decrypted_string =  ''.join([str(elem) for elem in decrypted_string_parts])
                decrypted_string_parts = []
                return decrypted_string
        
        
        ea = idc.next_head(ea, end)
    


def resolve(start,end,pattern):

    while True:
        start = ida_search.find_binary(start, end, pattern, 16, idc.SEARCH_NEXT|idc.SEARCH_DOWN)
        if start == idc.BADADDR:
                break
                
        ea = start
        start_addr = hex(recheck_addr(start,end))
        if start_addr not in exclued_addr:
            exclued_addr.append(start_addr)
            
            while 1 :
                ea = idc.next_head(ea, end)
                if (idc.print_insn_mnem(ea) == "xor") :
                    try:
                        decrypted_string = decrypt(int(start_addr,16))
                        idc.set_cmt(ea, decrypted_string, 1)
                        if decrypted_string in exports_list:
                                rename_api(ea,end,decrypted_string)
                    except:
                        decrypted_string = ""
                    break
               
    
resolve(start,end,pattern1)
resolve(start,end,pattern2)  
   
