import idautils , idc, idaapi, ida_search, ida_bytes, ida_auto
import struct

exclued_addr = []
decrypt_addrs_dict = {}


def set_hexrays_comment(address, text):
    '''
    set comment in decompiled code
    '''
    cfunc = idaapi.decompile(address)

    tl = idaapi.treeloc_t()
    tl.ea = address
    tl.itp = idaapi.ITP_SEMI
    cfunc.set_user_cmt(tl, text)
    cfunc.save_user_cmts() 


def set_comment(address, text):
    ## Set in dissassembly
    idc.set_cmt(address, text,0)
    ## Set in decompiled data
    set_hexrays_comment(address, text)

def getref(ea):
    for ref in idautils.XrefsTo(int(ea,16)):
            return ref.frm

fun_addr = 0x100077D0 # decryption fucntion address

def setup_dict():
    for ref in idautils.XrefsTo(fun_addr):
            ea = ref.frm
            addr = idc.get_func_name(ea).replace("sub_","0x")
            addr = getref(addr)
            addr = idc.get_func_name(addr).replace("sub_","0x")
            addr = getref(addr)
            decrypt_addrs_dict[hex(addr)] = hex(ea)
setup_dict()


def decrypt(encrypted_buffer,key):
    data  = ""
    for i in range(len(encrypted_buffer)):
        data += chr(encrypted_buffer[i]^((key >> (8 * (i % 8))) & 0xFF))
    return data.replace('\x00','')
    
    
def get_encrypted_buffer(ea,end , length):
    encrypted_buffer = []
    for i in range(length+1):
        if (idc.print_insn_mnem(ea) == "mov") and (idc.get_operand_type(ea, 0) == idc.o_displ) and (idc.get_operand_type(ea, 1) == idc.o_imm):
                    encrypted_buffer.append(idc.get_operand_value(ea, 1))
                    exclued_addr.append(hex(ea))                  
        ea = idc.next_head(ea, end)    
    return encrypted_buffer 


def get_16byte_decryption_key(ea):

        addrs = []
        while len(addrs)!= 4:
        
            ea = idc.prev_head(ea)
            if (idc.print_insn_mnem(ea) == "push") and idc.get_operand_type(ea, 0) == idc.o_imm:
                addrs.append((idc.get_operand_value(ea, 0)))
                
        length = hex(addrs[0])
        hexkey0_8 = "0x"+"0"*(8-len(hex(addrs[3])[2:]))+hex(addrs[3])[2:]
        hexkey8_16 = "0"*(8-len(hex(addrs[2])[2:]))+hex(addrs[2])[2:]
        key = hexkey0_8 +  hexkey8_16
        return length , key



pattern = "C6 45 ?? ?? C6 45 ?? ??"  #  encrypted data

seg_mapping = {idaapi.getseg(x).name: (idaapi.getseg(x).start_ea, idaapi.getseg(x).end_ea) for x in idautils.Segments()}
start = seg_mapping[0x1][0]
end = seg_mapping[0x1][1]      

while True:

        start = ida_search.find_binary(start, end, pattern, 16, idc.SEARCH_NEXT|idc.SEARCH_DOWN)
        if start == idc.BADADDR:
                break
                
        buuffer_addr = start
        addr =  hex(start)
        
        
        if addr not in exclued_addr:
            exclued_addr.append(addr)
            addr = idc.get_func_name(int(addr,16)).replace("sub_","0x")
            addr = getref(addr)
            ea  = addr
            
            while 1:
            
                ea = idc.next_head(ea, end)
                if idc.print_insn_mnem(ea) == "call":
                    length , key = get_16byte_decryption_key(int(decrypt_addrs_dict[hex(ea)],16))
                    encrypted_buffer = get_encrypted_buffer(buuffer_addr,end,int(length,16))
                    decrypted_buffer = decrypt(encrypted_buffer,int(key,16))
                    set_comment(ea, decrypted_buffer)
                    break
            

